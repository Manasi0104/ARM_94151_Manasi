/*
 * DHT11.c
 *
 *  Created on: Dec 30, 2025
 *      Author: ADMIN
 */
#include "dht11.h"
#include "main.h"
#include "my_lcd.h"

/* Standard C libraries */
#include <stdio.h>      // for
#include <string.h>     // for string handling
#include <stdarg.h>     // for variable arguments

/* STM32 HAL library */
#include "stm32f4xx_hal.h"
// i want to take 40 bits from Dht11
// step 1 : make dht11 low foe 18ms it will work as output
//step 2 :then make it high for 30us as input
//step 3 :then low for 80us wait to become high
//step 4 :then high for 80us wait to become low
//step 5 :read 40 bits
//in that 1st byte is humidity integer
//2nd byte is humidity decimal
// 3rd byte temp integer
//4th byte temp decimal
//5th parity
// then need to convert that into hex then decimal
//then display it on lcd as string
void DWT_Init(void)
{
    /* Enable TRC (Trace) unit
     * Without this, DWT registers will not work
     */
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;

    /* Reset cycle counter value to 0 */
    DWT->CYCCNT = 0;

    /* Enable the cycle counter (CYCCNT) */
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
}
void DWT_Delay_us(uint32_t us)
{
    /* Calculate number of CPU cycles needed for given delay
     * Example:
     * SystemCoreClock = 72 MHz
     * 1 Âµs = 72 cycles
     */
    uint32_t cycles = (SystemCoreClock / 1000000) * us;

    /* Store the current cycle counter value */
    uint32_t start = DWT->CYCCNT;

    /* Wait until required number of cycles have passed */
    while ((DWT->CYCCNT - start) < cycles);
}
char data[5];
int byte_index=0;
int data_index = 0;
void dht11_start_operation()
{
	char data[5];
	int byte_index=0;
	int data_index = 0;
	DHT11_Pin_Output();
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
	HAL_Delay(18);//18 ms delay to start signal
	//HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
	DHT11_Pin_Input();
	DWT_Delay_us(30);
	dht11_read_operation();
}
void dht11_read_operation()
{
	uint8_t d = 0;
		if(! HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_4))
		{
			DWT_Delay_us(80);
			while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_4)==GPIO_PIN_RESET);
			LL_TIM_COUNTERMODE_UP(TIM1,0);
			while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_4)==GPIO_PIN_SET);
			int time = LL_TIM_GetCounter(TIM1);
			if(time >= 70)
			{
				d = 1;
			}
			else
				d = 0;

		}
		while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_4)==GPIO_PIN_SET);
		char data[5];
			char str1[32];
			char str2[32];
			char str3[32];
			char str4[32];
			char str5[32];
			for(byte_index =0;byte_index < 5 ;byte_index++)
			{
				for(data_index =0;data_index <8;data_index++)
					{
					     data[byte_index]= a;
					     data[byte_index] |= (1<<(7-i);
					}
			}
			uint8_t hum_int =0,hum_dec =0,tem_int =0,tem_dec =0,parity = 0;
			hum_int = (uint8_t)data[0];
			hum_dec = (uint8_t)data[1];
			tem_int = (uint8_t)data[2];
			tem_dec = (uint8_t)data[3];
			parity =  (uint8_t)data[4];
			sprintf(str1,"%d",hum_int);
			lcd16x2_i2c_clear();
			lcd16x2_i2c_setCursor(0,0);
			lcd16x2_i2c_printf(str1);
			HAL_Delay(1000);
}

static void DHT11_Pin_Output(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = DHT11_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(DHT11_PORT, &GPIO_InitStruct);
}

static void DHT11_Pin_Input(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = DHT11_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(DHT11_PORT, &GPIO_InitStruct);
}





